<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>DocumentPreview Debug</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui;
            background: #1e293b;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #toolbar {
            padding: 8px 16px;
            background: #334155;
            border-bottom: 1px solid #475569;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #toolbar span {
            font-size: 13px;
            color: #94a3b8;
        }

        #stats {
            font-size: 12px;
            color: #22d3ee;
            font-family: monospace;
        }

        /* Scroll container — this is the same structure as the real component */
        #scroll-container {
            flex: 1;
            background: #0f172a;
            overflow: auto;
        }

        #pages-wrapper {
            display: flex;
            justify-content: center;
            padding: 32px;
            min-width: 100%;
        }

        #pages-column {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .typst-page {
            background: white;
            flex-shrink: 0;
        }

        .placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ccc;
            font-size: 12px;
        }

        .svg-content {
            width: 100%;
            height: 100%;
        }

        .svg-content svg {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <div id="toolbar">
        <span>DocumentPreview Debug — <strong id="page-count">0</strong> pages</span>
        <div id="stats">Visible: <span id="visible-set">none</span></div>
    </div>

    <div id="scroll-container">
        <div id="pages-wrapper">
            <div id="pages-column"></div>
        </div>
    </div>

    <script>
        // =====================================================
        // 1. Generate mock multi-page SVG string (like Typst output)
        // =====================================================
        const PAGE_COUNT = 7000;
        const PAGE_W = 595;
        const PAGE_H = 842;

        function generateMockSvgString(numPages) {
            // Typst outputs one <svg> per page, concatenated.
            const svgs = [];
            for (let i = 0; i < numPages; i++) {
                // Each SVG has some content to make it non-trivial
                svgs.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${PAGE_W} ${PAGE_H}">
        <rect width="${PAGE_W}" height="${PAGE_H}" fill="#fafafa"/>
        <text x="50" y="60" font-size="24" fill="#333">Page ${i + 1} of ${numPages}</text>
        <text x="50" y="100" font-size="14" fill="#666">This is mock content for testing virtualization.</text>
        ${Array.from({ length: 20 }, (_, j) =>
                    `<text x="50" y="${140 + j * 30}" font-size="12" fill="#888">Line ${j + 1}: Lorem ipsum dolor sit amet, consectetur adipiscing elit.</text>`
                ).join('\n')}
        <rect x="50" y="${PAGE_H - 60}" width="200" height="30" rx="4" fill="#3b82f6"/>
        <text x="90" y="${PAGE_H - 40}" font-size="12" fill="white">Page ${i + 1} footer</text>
      </svg>`);
            }
            return svgs.join('\n');
        }

        // =====================================================
        // 2. Parse pages — exact same logic as document-preview.tsx
        // =====================================================
        function parsePagesFromSvg(svgString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, "text/html");
            const svgElements = doc.querySelectorAll("svg");

            const pages = [];
            svgElements.forEach((svgEl, index) => {
                const viewBox = svgEl.getAttribute("viewBox") || "";
                const parts = viewBox.split(" ").map(Number);
                const width = parts[2] || 600;
                const height = parts[3] || 800;
                pages.push({ index, width, height, svgContent: svgEl.outerHTML });
            });
            return pages;
        }

        // =====================================================
        // 3. Render pages + IntersectionObserver virtualization
        //    — exact same logic as our useInView hook
        // =====================================================
        const svgString = generateMockSvgString(PAGE_COUNT);
        const pages = parsePagesFromSvg(svgString);

        document.getElementById('page-count').textContent = pages.length;

        const column = document.getElementById('pages-column');
        const visibleSet = new Set();

        // Create all page placeholders
        pages.forEach((page) => {
            const div = document.createElement('div');
            div.className = 'typst-page';
            div.dataset.page = String(page.index);
            div.style.width = page.width + 'px';
            div.style.height = page.height + 'px';
            div.innerHTML = `<div class="placeholder">Page ${page.index + 1}</div>`;
            column.appendChild(div);
        });

        // Set up IntersectionObserver (mirrors our React hook)
        const container = document.getElementById('scroll-container');

        const observer = new IntersectionObserver(
            (entries) => {
                for (const entry of entries) {
                    const idx = Number(entry.target.dataset.page);
                    if (entry.isIntersecting) {
                        visibleSet.add(idx);
                        // Inject SVG
                        entry.target.innerHTML = `<div class="svg-content">${pages[idx].svgContent}</div>`;
                    } else {
                        visibleSet.delete(idx);
                        // Replace with placeholder
                        entry.target.innerHTML = `<div class="placeholder">Page ${idx + 1}</div>`;
                    }
                }
                // Update stats display
                const sorted = Array.from(visibleSet).sort((a, b) => a - b);
                document.getElementById('visible-set').textContent =
                    sorted.length > 0 ? sorted.map(i => i + 1).join(', ') : 'none';

                console.log('[observer] Visible pages:', sorted.map(i => i + 1));
            },
            {
                root: container,
                rootMargin: "100% 0px",
            }
        );

        // Observe all page divs
        column.querySelectorAll('[data-page]').forEach((el) => observer.observe(el));

        console.log(`[init] Created ${pages.length} pages, observing with root=scroll-container, rootMargin="100% 0px"`);
    </script>

</body>

</html>