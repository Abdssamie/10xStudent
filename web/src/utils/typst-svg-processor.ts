/**
 * Processes the raw SVG output from Typst to simulate a multi-page document view.
 * Uses the fault-tolerant HTML parser to avoid strict XML entity crashes (like &nbsp;).
 */
export function processTypstSvg(rawSvg: string): string {
  const gapSize = 30;

  // 1. Parse as HTML instead of strict XML.
  // Wrapping in a div ensures the parser treats it as an embedded HTML element.
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div>${rawSvg}</div>`, "text/html");

  // 2. Grab the SVG root generated by the HTML parser
  const svgRoot = doc.querySelector("svg");
  if (!svgRoot) return rawSvg; // Fallback if parsing completely fails

  // 3. Safely grab all page groups
  const pages = svgRoot.querySelectorAll("g.typst-page");
  const totalPages = pages.length;

  if (totalPages === 0) return rawSvg;

  const svgNS = "http://www.w3.org/2000/svg";

  // 4. Process each page iteratively
  pages.forEach((page, index) => {
    const transform = page.getAttribute("transform") || "";
    const w = page.getAttribute("data-page-width") || "0";
    const h = page.getAttribute("data-page-height") || "0";

    const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    const x = translateMatch ? parseFloat(translateMatch[1] || "0") : 0;
    const y = translateMatch ? parseFloat(translateMatch[2] || "0") : 0;

    const newY = y + index * gapSize;

    const wrapper = document.createElementNS(svgNS, "g");
    wrapper.setAttribute("class", "typst-page-wrapper");
    wrapper.setAttribute("transform", `translate(${x}, ${newY})`);

    const shadowRect = document.createElementNS(svgNS, "rect");
    shadowRect.setAttribute("width", w);
    shadowRect.setAttribute("height", h);
    shadowRect.setAttribute("fill", "white");
    shadowRect.setAttribute("class", "shadow-md");
    shadowRect.setAttribute(
      "style",
      "filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1)) drop-shadow(0 10px 15px rgba(0,0,0,0.05));",
    );

    page.setAttribute("transform", "translate(0, 0)");

    page.parentNode?.insertBefore(wrapper, page);
    wrapper.appendChild(shadowRect);
    wrapper.appendChild(page);
  });

  // 5. Update the root <svg> dimensions to account for the new gaps
  const totalAddedHeight = (totalPages - 1) * gapSize;

  const viewBox = svgRoot.getAttribute("viewBox");
  if (viewBox) {
    const parts = viewBox.split(" ").map(parseFloat);
    const vx = parts[0] ?? 0;
    const vy = parts[1] ?? 0;
    const vw = parts[2] ?? 0;
    const vh = parts[3] ?? 0;
    svgRoot.setAttribute(
      "viewBox",
      `${vx} ${vy} ${vw} ${vh + totalAddedHeight}`,
    );
  }

  const heightAttr = svgRoot.getAttribute("height");
  if (heightAttr) {
    const currentHeight = parseFloat(heightAttr);
    const unitMatch = heightAttr.match(/[a-z]+$/i);
    const unit = unitMatch ? unitMatch[0] : "";
    svgRoot.setAttribute(
      "height",
      `${currentHeight + totalAddedHeight}${unit}`,
    );
  }

  // 6. Return the modified SVG string directly from the DOM node
  return svgRoot.outerHTML;
}
