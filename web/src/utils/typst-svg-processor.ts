/**
 * Processes the raw SVG output from Typst to add visual enhancements.
 * 
 * For viewport-based rendering, this processor:
 * - Adds drop shadows to page backgrounds
 * - Preserves original positioning (handled by viewport window)
 * 
 * For legacy full-document rendering, it also:
 * - Adds gaps between pages
 * - Adjusts viewBox/height dimensions
 */

/** Result of SVG processing */
export interface ProcessTypstSvgResult {
  success: true;
  svg: string;
}

/** Error result of SVG processing */
export interface ProcessTypstSvgError {
  success: false;
  error: string;
  fallbackSvg?: string;
}

/** Options for SVG processing */
export interface ProcessTypstSvgOptions {
  /** If true, skip gap insertion and dimension adjustments (for viewport rendering) */
  viewportMode?: boolean;
}

// Reusable SVG element for parsing transforms without DOM thrashing
let parseSvg: SVGSVGElement | null = null;
let parseGroup: SVGGElement | null = null;

/**
 * Cleans up the reusable SVG elements used for transform parsing.
 * Call this when the module is no longer needed to prevent memory leaks.
 */
export function cleanupSvgParser(): void {
  if (parseSvg && parseSvg.parentNode) {
    parseSvg.parentNode.removeChild(parseSvg);
  }
  parseSvg = null;
  parseGroup = null;
}

function getTransformValues(transform: string): { x: number; y: number } {
  if (!parseSvg) {
    parseSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    parseSvg.style.position = "absolute";
    parseSvg.style.visibility = "hidden";
    parseSvg.style.width = "0";
    parseSvg.style.height = "0";
    parseSvg.style.pointerEvents = "none";
    document.body.appendChild(parseSvg);
    parseGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    parseSvg.appendChild(parseGroup);
  }

  parseGroup!.setAttribute("transform", transform);
  const matrix = parseGroup!.getCTM();
  return { x: matrix?.e ?? 0, y: matrix?.f ?? 0 };
}

/**
 * Validates that the input is a non-empty string containing SVG content.
 * @throws {Error} If input is invalid
 */
function validateInput(rawSvg: unknown): asserts rawSvg is string {
  if (typeof rawSvg !== "string") {
    throw new Error(
      `Expected SVG string, received ${typeof rawSvg}`,
    );
  }
  if (rawSvg.trim().length === 0) {
    throw new Error("SVG input is empty");
  }
  if (!rawSvg.includes("<svg") && !rawSvg.includes("<SVG")) {
    throw new Error("Input does not contain valid SVG markup");
  }
}

/**
 * Parses raw SVG string into a DOM document.
 * @throws {Error} If parsing fails
 */
function parseSvgDocument(rawSvg: string): Document {
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div>${rawSvg}</div>`, "text/html");

  // Check for parsing errors
  const parserError = doc.querySelector("parsererror");
  if (parserError) {
    throw new Error(
      `SVG parsing failed: ${parserError.textContent || "Unknown parsing error"}`,
    );
  }

  return doc;
}

/**
 * Processes the raw SVG output from Typst to add visual enhancements.
 * @param rawSvg - The raw SVG string from Typst compilation
 * @param options - Processing options
 * @returns Processed SVG string
 * @throws {Error} If processing fails
 */
export function processTypstSvg(rawSvg: string, options: ProcessTypstSvgOptions = {}): string {
  const { viewportMode = false } = options;
  const gapSize = viewportMode ? 0 : 30; // No gaps in viewport mode

  // 1. Validate input
  validateInput(rawSvg);

  // 2. Parse as HTML
  let doc: Document;
  try {
    doc = parseSvgDocument(rawSvg);
  } catch (err) {
    console.error("[typst-svg-processor] Failed to parse SVG:", err);
    throw err instanceof Error
      ? err
      : new Error("Failed to parse SVG document", err as Error);
  }

  // 3. Grab the SVG root generated by the HTML parser
  const svgRoot = doc.querySelector("svg");

  if (!svgRoot) {
    throw new Error(
      "No SVG element found in parsed document",
    );
  }

  // 4. Safely grab all page groups
  const pages = svgRoot.querySelectorAll("g.typst-page");
  const pagesLength = pages.length;

  if (pagesLength === 0) {
    // No pages found - return original but warn
    console.warn(
      "[typst-svg-processor] No .typst-page elements found, returning unmodified SVG",
    );
    return rawSvg;
  }

  const svgNS = "http://www.w3.org/2000/svg";

  // 5. Process each page iteratively
  try {
    pages.forEach((page, index) => {
      const transform = page.getAttribute("transform") || "";
      const w = page.getAttribute("data-page-width") || "0";
      const h = page.getAttribute("data-page-height") || "0";

      // Parse transform using cached SVG element
      let x: number;
      let y: number;
      try {
        const transformValues = getTransformValues(transform);
        x = transformValues.x;
        y = transformValues.y;
      } catch (transformErr) {
        console.warn(
          `[typst-svg-processor] Failed to parse transform for page ${index}:`,
          transformErr,
        );
        x = 0;
        y = 0;
      }

      const newY = viewportMode ? y : y + index * gapSize;

      const wrapper = document.createElementNS(svgNS, "g");
      wrapper.setAttribute("class", "typst-page-wrapper");
      wrapper.setAttribute("transform", `translate(${x}, ${newY})`);

      const shadowRect = document.createElementNS(svgNS, "rect");
      shadowRect.setAttribute("width", w);
      shadowRect.setAttribute("height", h);
      shadowRect.setAttribute("fill", "white");
      shadowRect.setAttribute("class", "shadow-md");
      shadowRect.setAttribute(
        "style",
        "filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1)) drop-shadow(0 10px 15px rgba(0,0,0,0.05));",
      );

      page.setAttribute("transform", "translate(0, 0)");

      const parent = page.parentNode;
      if (!parent) {
        console.warn(
          `[typst-svg-processor] Page ${index} has no parent node, skipping`,
        );
        return;
      }

      parent.insertBefore(wrapper, page);
      wrapper.appendChild(shadowRect);
      wrapper.appendChild(page);
    });
  } catch (processingErr) {
    throw new Error(
      "Failed to process SVG pages",
      processingErr as Error,
    );
  }

  // 6. Update the root <svg> dimensions (skip in viewport mode)
  if (!viewportMode) {
    const totalAddedHeight = (pagesLength - 1) * gapSize;

    try {
      const viewBox = svgRoot.getAttribute("viewBox");
      if (viewBox) {
        const parts = viewBox.split(" ").map(parseFloat);
        const vx = parts[0] ?? 0;
        const vy = parts[1] ?? 0;
        const vw = parts[2] ?? 0;
        const vh = parts[3] ?? 0;

        if (Number.isFinite(vx) && Number.isFinite(vy) && Number.isFinite(vw) && Number.isFinite(vh)) {
          svgRoot.setAttribute(
            "viewBox",
            `${vx} ${vy} ${vw} ${vh + totalAddedHeight}`,
          );
        } else {
          console.warn("[typst-svg-processor] Invalid viewBox values, skipping update");
        }
      }

      const heightAttr = svgRoot.getAttribute("height");
      if (heightAttr) {
        const currentHeight = parseFloat(heightAttr);
        if (Number.isFinite(currentHeight)) {
          const unitMatch = heightAttr.match(/[a-z]+$/i);
          const unit = unitMatch ? unitMatch[0] : "";
          svgRoot.setAttribute(
            "height",
            `${currentHeight + totalAddedHeight}${unit}`,
          );
        } else {
          console.warn("[typst-svg-processor] Invalid height attribute, skipping update");
        }
      }
    } catch (dimensionErr) {
      console.warn(
        "[typst-svg-processor] Failed to update SVG dimensions:",
        dimensionErr,
      );
      // Non-fatal: continue with modified SVG
    }
  }

  // 7. Return the modified SVG string directly from the DOM node
  return svgRoot.outerHTML;
}

/**
 * Safely processes Typst SVG with error handling.
 * Returns a result object instead of throwing.
 * @param rawSvg - The raw SVG string from Typst compilation
 * @returns Result object with either processed SVG or error info
 */
export function processTypstSvgSafe(
  rawSvg: string,
): ProcessTypstSvgResult | ProcessTypstSvgError {
  try {
    const svg = processTypstSvg(rawSvg);
    return { success: true, svg };
  } catch (err) {
    const errorMessage =
      err instanceof Error
        ? err.message
        : "Unknown SVG processing error";

    console.error("[typst-svg-processor] Processing failed:", err);

    return {
      success: false,
      error: errorMessage,
      fallbackSvg: rawSvg,
    };
  }
}
